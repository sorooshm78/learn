<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.95.0">
  <link rel="canonical" href="https://www.fluentpython.com/extra/internals-of-sets-and-dicts/">

  
    
    <meta name="description" content="Python’s dict and set are built on top of hash tables. This post explains how the use of hash tables results in the strengths and limitations of those container types.
 Here are some questions this article answers:
   How efficient are Python dict and set?
  Why are set elements unordered?
  Why can’t we use any Python object as a dict key or set element?">
  

  <link rel="apple-touch-icon" sizes="180x180" href="https://fluentpython.com/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://fluentpython.com/favicon-32x32.png"> 
  <link rel="icon" type="image/png" sizes="16x16" href="https://fluentpython.com/favicon-16x16.png"> 
  <link rel="manifest" href="https://fluentpython.com/site.webmanifest"> 
  <link rel="mask-icon" href="https://fluentpython.com/safari-pinned-tab.svg" color="#000000"> 
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <style>
    body {
      visibility: hidden;
      opacity: 0;
    }
  </style>

  <link rel="stylesheet" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/prism.css" media="all" onload="this.media='all';">

  
  
  <link rel="stylesheet" type="text/css" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/styles.css">

  
    <link rel="stylesheet" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/custom_01.css">
  
    <link rel="stylesheet" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/custom_02.css">
  

  
  
  <title>Internals of sets and dicts | Fluent Python, the lizard book</title>
</head>

  <body style="visibility: visible; opacity: 1;">
    <a href="#main">skip to content</a>
    <noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>

    <svg style="display: none">
  <symbol id="bookmark" viewBox="0 0 40 50">
   <g transform="translate(2266 3206.2)">
    <path style="stroke:currentColor;stroke-width:3.2637;fill:none" d="m-2262.2-3203.4-.2331 42.195 16.319-16.318 16.318 16.318.2331-42.428z"></path>
   </g>
  </symbol>

  <symbol id="w3c" viewBox="0 0 127.09899 67.763">
   <text font-size="83" style="font-size:83px;font-family:Trebuchet;letter-spacing:-12;fill-opacity:0" letter-spacing="-12" y="67.609352" x="-26.782778">W3C</text>
   <text font-size="83" style="font-size:83px;font-weight:bold;font-family:Trebuchet;fill-opacity:0" y="67.609352" x="153.21722" font-weight="bold">SVG</text>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m33.695.377 12.062 41.016 12.067-41.016h8.731l-19.968 67.386h-.831l-12.48-41.759-12.479 41.759h-.832l-19.965-67.386h8.736l12.061 41.016 8.154-27.618-3.993-13.397h8.737z"></path>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m91.355 46.132c0 6.104-1.624 11.234-4.862 15.394-3.248 4.158-7.45 6.237-12.607 6.237-3.882 0-7.263-1.238-10.148-3.702-2.885-2.47-5.02-5.812-6.406-10.022l6.82-2.829c1.001 2.552 2.317 4.562 3.953 6.028 1.636 1.469 3.56 2.207 5.781 2.207 2.329 0 4.3-1.306 5.909-3.911 1.609-2.606 2.411-5.738 2.411-9.401 0-4.049-.861-7.179-2.582-9.399-1.995-2.604-5.129-3.912-9.397-3.912h-3.327v-3.991l11.646-20.133h-14.062l-3.911 6.655h-2.493v-14.976h32.441v4.075l-12.31 21.217c4.324 1.385 7.596 3.911 9.815 7.571 2.22 3.659 3.329 7.953 3.329 12.892z"></path>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.21 0 1.414 8.6-5.008 9.583s-1.924-4.064-5.117-6.314c-2.693-1.899-4.447-2.309-7.186-1.746-3.527.73-7.516 4.938-9.258 10.13-2.084 6.21-2.104 9.218-2.178 11.978-.115 4.428.58 7.043.58 7.043s-3.04-5.626-3.011-13.866c.018-5.882.947-11.218 3.666-16.479 2.404-4.627 5.954-7.404 9.114-7.728 3.264-.343 5.848 1.229 7.841 2.938 2.089 1.788 4.213 5.698 4.213 5.698l4.94-9.837z"></path>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.82 48.674s-2.208 3.957-3.589 5.48c-1.379 1.524-3.849 4.209-6.896 5.555-3.049 1.343-4.646 1.598-7.661 1.306-3.01-.29-5.807-2.032-6.786-2.764-.979-.722-3.486-2.864-4.897-4.854-1.42-2-3.634-5.995-3.634-5.995s1.233 4.001 2.007 5.699c.442.977 1.81 3.965 3.749 6.572 1.805 2.425 5.315 6.604 10.652 7.545 5.336.945 9.002-1.449 9.907-2.031.907-.578 2.819-2.178 4.032-3.475 1.264-1.351 2.459-3.079 3.116-4.108.487-.758 1.276-2.286 1.276-2.286l-1.276-6.644z"></path>
  </symbol>

  <symbol id="tag" viewBox="0 0 177.16535 177.16535">
    <g transform="translate(0 -875.2)">
     <path style="fill-rule:evenodd;stroke-width:0;fill:currentColor" d="m159.9 894.3-68.79 8.5872-75.42 77.336 61.931 60.397 75.429-76.565 6.8495-69.755zm-31.412 31.835a10.813 10.813 0 0 1 1.8443 2.247 10.813 10.813 0 0 1 -3.5174 14.872l-.0445.0275a10.813 10.813 0 0 1 -14.86 -3.5714 10.813 10.813 0 0 1 3.5563 -14.863 10.813 10.813 0 0 1 13.022 1.2884z"></path>
    </g>
  </symbol>

  <symbol id="balloon" viewBox="0 0 141.73228 177.16535">
   <g transform="translate(0 -875.2)">
    <g>
     <path style="fill:currentColor" d="m68.156 882.83-.88753 1.4269c-4.9564 7.9666-6.3764 17.321-5.6731 37.378.36584 10.437 1.1246 23.51 1.6874 29.062.38895 3.8372 3.8278 32.454 4.6105 38.459 4.6694-.24176 9.2946.2879 14.377 1.481 1.2359-3.2937 5.2496-13.088 8.886-21.623 6.249-14.668 8.4128-21.264 10.253-31.252 1.2464-6.7626 1.6341-12.156 1.4204-19.764-.36325-12.93-2.1234-19.487-6.9377-25.843-2.0833-2.7507-6.9865-7.6112-7.9127-7.8436-.79716-.20019-6.6946-1.0922-6.7755-1.0248-.02213.0182-5.0006-.41858-7.5248-.22808l-2.149-.22808h-3.3738z"></path>
     <path style="fill:currentColor" d="m61.915 883.28-3.2484.4497c-1.7863.24724-3.5182.53481-3.8494.63994-2.4751.33811-4.7267.86957-6.7777 1.5696-.28598 0-1.0254.20146-2.3695.58589-5.0418 1.4418-6.6374 2.2604-8.2567 4.2364-6.281 7.6657-11.457 18.43-12.932 26.891-1.4667 8.4111.71353 22.583 5.0764 32.996 3.8064 9.0852 13.569 25.149 22.801 37.517 1.3741 1.841 2.1708 2.9286 2.4712 3.5792 3.5437-1.1699 6.8496-1.9336 10.082-2.3263-1.3569-5.7831-4.6968-21.86-6.8361-33.002-.92884-4.8368-2.4692-14.322-3.2452-19.991-.68557-5.0083-.77707-6.9534-.74159-15.791.04316-10.803.41822-16.162 1.5026-21.503 1.4593-5.9026 3.3494-11.077 6.3247-15.852z"></path>
     <path style="fill:currentColor" d="m94.499 885.78c-.10214-.0109-.13691 0-.0907.0409.16033.13489 1.329 1.0675 2.5976 2.0723 6.7003 5.307 11.273 14.568 12.658 25.638.52519 4.1949.24765 14.361-.5059 18.523-2.4775 13.684-9.7807 32.345-20.944 53.519l-3.0559 5.7971c2.8082.76579 5.7915 1.727 8.9926 2.8441 11.562-11.691 18.349-19.678 24.129-28.394 7.8992-11.913 11.132-20.234 12.24-31.518.98442-10.02-1.5579-20.876-6.7799-28.959-.2758-.4269-.57803-.86856-.89617-1.3166-3.247-6.13-9.752-12.053-21.264-16.131-2.3687-.86369-6.3657-2.0433-7.0802-2.1166z"></path>
     <path style="fill:currentColor" d="m32.52 892.22c-.20090-.13016-1.4606.81389-3.9132 2.7457-11.486 9.0476-17.632 24.186-16.078 39.61.79699 7.9138 2.4066 13.505 5.9184 20.562 5.8577 11.77 14.749 23.219 30.087 38.74.05838.059.12188.1244.18052.1838 1.3166-.5556 2.5965-1.0618 3.8429-1.5199-.66408-.32448-1.4608-1.3297-3.8116-4.4602-5.0951-6.785-8.7512-11.962-13.051-18.486-5.1379-7.7948-5.0097-7.5894-8.0586-13.054-6.2097-11.13-8.2674-17.725-8.6014-27.563-.21552-6.3494.13041-9.2733 1.775-14.987 2.1832-7.5849 3.9273-10.986 9.2693-18.07 1.7839-2.3656 2.6418-3.57 2.4409-3.7003z"></path>
     <path style="fill:currentColor" d="m69.133 992.37c-6.2405.0309-12.635.76718-19.554 2.5706 4.6956 4.7759 9.935 10.258 12.05 12.625l4.1272 4.6202h11.493l3.964-4.4516c2.0962-2.3541 7.4804-7.9845 12.201-12.768-8.378-1.4975-16.207-2.6353-24.281-2.5955z"></path>
     <rect style="stroke-width:0;fill:currentColor" ry="2.0328" height="27.746" width="22.766" y="1017.7" x="60.201"></rect>
    </g>
   </g>
  </symbol>

  <symbol id="info" viewBox="0 0 41.667 41.667">
   <g transform="translate(-37.035 -1004.6)">
    <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m76.25 1030.2a18.968 18.968 0 0 1 -23.037 13.709 18.968 18.968 0 0 1 -13.738 -23.019 18.968 18.968 0 0 1 23.001 -13.768 18.968 18.968 0 0 1 13.798 22.984"></path>
    <g transform="matrix(1.1146 0 0 1.1146 -26.276 -124.92)">
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m75.491 1039.5v-8.7472"></path>
     <path style="stroke-width:0;fill:currentColor" transform="scale(-1)" d="m-73.193-1024.5a2.3719 2.3719 0 0 1 -2.8807 1.7142 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"></path>
    </g>
   </g>
  </symbol>

  <symbol id="warning" viewBox="0 0 48.430474 41.646302">
    <g transform="translate(-1.1273 -1010.2)">
     <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:4.151;fill:none" d="m25.343 1012.3-22.14 37.496h44.28z"></path>
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:4.1512;fill:none" d="m25.54 1027.7v8.7472"></path>
     <path style="stroke-width:0;fill:currentColor" d="m27.839 1042.8a2.3719 2.3719 0 0 1 -2.8807 1.7143 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"></path>
    </g>
  </symbol>

  <symbol id="menu" viewBox="0 0 50 50">
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="0" x="0"></rect>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="20" x="0"></rect>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="40" x="0"></rect>
   </symbol>

   <symbol id="link" viewBox="0 0 50 50">
    <g transform="translate(0 -1002.4)">
     <g transform="matrix(.095670 0 0 .095670 2.3233 1004.9)">
      <g>
       <path style="stroke-width:0;fill:currentColor" d="m452.84 192.9-128.65 128.65c-35.535 35.54-93.108 35.54-128.65 0l-42.881-42.886 42.881-42.876 42.884 42.876c11.845 11.822 31.064 11.846 42.886 0l128.64-128.64c11.816-11.831 11.816-31.066 0-42.9l-42.881-42.881c-11.822-11.814-31.064-11.814-42.887 0l-45.928 45.936c-21.292-12.531-45.491-17.905-69.449-16.291l72.501-72.526c35.535-35.521 93.136-35.521 128.64 0l42.886 42.881c35.535 35.523 35.535 93.141-.001 128.66zm-254.28 168.51-45.903 45.9c-11.845 11.846-31.064 11.817-42.881 0l-42.884-42.881c-11.845-11.821-11.845-31.041 0-42.886l128.65-128.65c11.819-11.814 31.069-11.814 42.884 0l42.886 42.886 42.876-42.886-42.876-42.881c-35.54-35.521-93.113-35.521-128.65 0l-128.65 128.64c-35.538 35.545-35.538 93.146 0 128.65l42.883 42.882c35.51 35.54 93.11 35.54 128.65 0l72.496-72.499c-23.956 1.597-48.092-3.784-69.474-16.283z"></path>
      </g>
     </g>
    </g>
  </symbol>

  <symbol id="doc" viewBox="0 0 35 45">
   <g transform="translate(-147.53 -539.83)">
    <path style="stroke:currentColor;stroke-width:2.4501;fill:none" d="m149.38 542.67v39.194h31.354v-39.194z"></path>
    <g style="stroke-width:25" transform="matrix(.098003 0 0 .098003 133.69 525.96)">
     <path d="m220 252.36h200" style="stroke:currentColor;stroke-width:25;fill:none"></path>
     <path style="stroke:currentColor;stroke-width:25;fill:none" d="m220 409.95h200"></path>
     <path d="m220 488.74h200" style="stroke:currentColor;stroke-width:25;fill:none"></path>
     <path d="m220 331.15h200" style="stroke:currentColor;stroke-width:25;fill:none"></path>
    </g>
   </g>
 </symbol>

 <symbol id="tick" viewBox="0 0 177.16535 177.16535">
  <g transform="translate(0 -875.2)">
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="155" width="40" y="702.99" x="556.82"></rect>
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="40" width="90.404" y="817.99" x="506.42"></rect>
  </g>
 </symbol>
</svg>

    <div class="wrapper">
      <header class="intro-and-nav" role="banner">
  <div>
    <div class="intro">
      <a class="logo" href="https://fluentpython.com/" aria-label="Fluent Python, the lizard book home page">
        <img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/lizard-color.png" alt="Engraving of a Namaqua sand lizard (Pedioplanis namaquensis)">
      </a>
      <p class="library-desc">
         Companion site for the book <a href="https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/">Fluent Python, Second Edition</a>. 
      </p>
    </div>
    <nav id="patterns-nav" class="patterns" role="navigation">
  <h2 class="vh">Main navigation</h2>
  <button id="menu-button" aria-expanded="false">
    <svg viewBox="0 0 50 50" aria-hidden="true" focusable="false">
      <use xlink:href="#menu"></use>
    </svg>
    Menu
  </button>
  
  <ul id="patterns-list">
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Home</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/extra/">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Extra Content</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/lingo/">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Python Lingo</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/tags/">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Tags</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/about/">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">About</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="https://www.fluentpython.com/index.xml">
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">RSS</span>
      </a>
    </li>
  
  </ul>
</nav>
    
  </div>
</header>

      <div class="main-and-footer">
        <div>
          
  <main id="main">
    <h1>Internals of sets and dicts</h1>
    <div class="paragraph">
<p>Python’s <code>dict</code> and <code>set</code> are built on top of hash tables.
This post explains how the use of hash tables results in
the strengths and limitations of those container types.</p>
</div>
<div class="paragraph">
<p>Here are some questions this article answers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How efficient are Python <code>dict</code> and <code>set</code>?</p>
</li>
<li>
<p>Why are <code>set</code> elements unordered?</p>
</li>
<li>
<p>Why can’t we use any Python object as a <code>dict</code> key or <code>set</code> element?</p>
</li>
<li>
<p>Why does the order of the <code>dict</code> keys depend on insertion order?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#perf_experim_sec">A Performance Experiment</a></p>
</li>
<li>
<p><a href="#hashes_and_equality">Hashes and equality</a></p>
</li>
<li>
<p><a href="#set_hash_tables_under_sec">Set hash tables under the hood</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#hash_table_algorithm_sec">The hash table algorithm</a></p>
</li>
<li>
<p><a href="#consequences_set_sec">Practical Consequences of How Sets Work</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#hash_table_in_dict_sec">Hash table usage in <code>dict</code></a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#key_sharing_dict_sec">Key-sharing dictionary</a></p>
</li>
<li>
<p><a href="#how_compact_dict_ordering_sec">How compact <code>dict</code> saves space and keeps ordering</a></p>
</li>
<li>
<p><a href="#consequences_dict_sec">Practical Consequences of How dict Works</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>You don’t need to know all of these details to make good use of dictionaries and sets.
But the implementation ideas are beautiful—that’s why I describe them.
For practical advice, you can skip to <a href="#consequences_set_sec">Practical Consequences of How Sets Work</a> and <a href="#consequences_dict_sec">Practical Consequences of How dict Works</a>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>To motivate the study of hash tables, we start by showcasing the amazing performance of <code>dict</code> and <code>set</code> with a simple test involving millions of items.</p>
</div>
<div class="sect1">
<h2 id="perf_experim_sec">A Performance Experiment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>From experience, all Pythonistas know that dicts and sets are fast. We’ll confirm that with a controlled experiment.</p>
</div>
<div class="paragraph">
<p>To see how the size of a <code>dict</code>, <code>set</code>, or <code>list</code> affects the performance of search using the <code>in</code>
 operator, I generated an array of 10 million distinct double-precision 
floats, the "haystack." I then generated an array of needles: 1,000 
floats, with 500 picked from the haystack and 500 verified not to be in 
it.</p>
</div>
<div class="paragraph">
<p>For the <code>dict</code> benchmark, I used <code>dict.fromkeys()</code> to create a <code>dict</code> named <code>haystack</code> with 1,000 floats. This was the setup for the <code>dict</code> test. The actual code I clocked with the <code>timeit</code> module is <a href="#ex_for_perf">Example 1</a> (like <a href="#ex_set_loop_ex">[ex_set_loop_ex]</a>).</p>
</div>
<div id="ex_for_perf" class="exampleblock">
<div class="title">Example 1. Search for needles in haystack and count those found</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight language-python3" role="region" aria-label="code sample"><code class=" language-python3" data-lang="python3">found = 0
for n in needles:
    if n in haystack:
        found += 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>I repeated the benchmark five times, each time increasing tenfold the size of <code>haystack</code>, from 1,000 to 10,000,000 items. The result of the <code>dict</code> performance test is in <a href="#table_dict_time">Figure 1</a>.</p>
</div>
<div id="table_dict_time" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/table-dict-time.png" alt="Table showing timings for searching in dicts of sizes from 1,000 to 10,000,000.">
</div>
<div class="title">Figure 1. Table 3-6</div>
</div>
<div class="paragraph">
<p>In concrete terms, to check for the presence of 1,000 floating-point keys in a dictionary with 1,000 items,
the processing time on my laptop was 99µs, and the same search in a <code>dict</code>
 with 10,000,000 items took 512µs.
In other words, the average time for each search in the haystack with 10
 million items was 0.512µs—​yes, that’s about half microsecond per 
needle.
When the search space became 10,000 times larger, the search time 
increased a little over 5 times. Nice.</p>
</div>
<div class="paragraph">
<p>To compare with other collections, I repeated the benchmark with the same haystacks of increasing size, but storing the <code>haystack</code> as a <code>set</code> or as <code>list</code>. For the <code>set</code> tests, in addition to timing the <code>for</code> loop in <a href="#ex_for_perf">Example 1</a>, I also timed the one-liner in <a href="#ex_intersect_perf">Example 2</a>, which produces the same result: count the number of elements from <code>needles</code> that are also in <code>haystack</code>—if both are sets.</p>
</div>
<div id="ex_intersect_perf" class="exampleblock">
<div class="title">Example 2. Use set intersection to count the needles that occur in haystack</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight language-python3" role="region" aria-label="code sample"><code class=" language-python3" data-lang="python3">found = len(needles &amp; haystack)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#table_dict_set_list_time">Figure 2</a> shows the tests side by side. The best times are in the "set&amp; time" column, which displays results for the set <code>&amp;</code> operator using the code from <a href="#ex_intersect_perf">Example 2</a>.
As expected, the worst times are in the "list time" column, because there is no hash table to support searches with the <code>in</code> operator on a <code>list</code>, so a full scan must be made if the needle is not present, resulting in times that grow linearly with the size of the haystack.</p>
</div>
<div id="table_dict_set_list_time" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/table-dict-set-list-time.png" alt="Table showing timings for searching in dicts, sets, and lists of sizes from 1,000 to 10,000,000.">
</div>
<div class="title">Figure 2. Table 3-7</div>
</div>
<div class="paragraph">
<p>If your program does any kind of I/O, the lookup time for keys in dicts or sets is negligible, regardless of the <code>dict</code> or <code>set</code> size (as long as it fits in RAM). See the code used to generate <a href="#set_dict_search_time_tbl">[set_dict_search_time_tbl]</a> and accompanying discussion in <a href="#support_scripts">[support_scripts]</a>, <a href="#support_container_perftest">[support_container_perftest]</a>.</p>
</div>
<div class="paragraph">
<p>Now that we have concrete evidence of the speed of dicts and sets, 
let’s explore how that is achieved with the help of hash tables.</p>
</div>
<div class="paragraph">
<p>Before studying hash tables, we need to know more about hash codes, and how they relate to equality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hashes_and_equality">Hashes and equality</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>hash()</code> built-in function works directly with built-in types and falls back to calling <code>__hash__</code>
 for user-defined types. If two objects compare equal, their hash codes 
must also be equal, otherwise the hash table algorithm does not work. 
For example, because <code>1 == 1.0</code> is <code>True</code>, <code>hash(1) == hash(1.0)</code> must also be <code>True</code>, even though the internal representation of an <code>int</code> and a <code>float</code> are very different.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>Also, to be effective as hash table indexes, hash codes should 
scatter around the index space as much as possible. This means that, 
ideally, objects that are similar but not equal should have hash codes 
that differ widely. <a href="#ex_hashdiff_output">Example 3</a> is the 
output of a script to compare the bit patterns of hash codes. Note how 
the hashes of 1 and 1.0 are the same, but those of 1.0001, 1.0002, and 
1.0003 are very different.</p>
</div>
<div id="ex_hashdiff_output" class="exampleblock">
<div class="title">Example 3. Comparing hash bit patterns of 1, 1.0001, 
1.0002, and 1.0003 on a 32-bit build of Python (bits that are different 
in the hashes above and below are highlighted with ! and the right 
column shows the number of bits that differ)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight" role="region" aria-label="code sample"><code>32-bit Python build
1        00000000000000000000000000000001
                                          != 0
1.0      00000000000000000000000000000001
------------------------------------------------
1.0      00000000000000000000000000000001
           ! !!! ! !! ! !    ! ! !! !!!   != 16
1.0001   00101110101101010000101011011101
------------------------------------------------
1.0001   00101110101101010000101011011101
          !!!  !!!! !!!!!   !!!!! !!  !   != 20
1.0002   01011101011010100001010110111001
------------------------------------------------
1.0002   01011101011010100001010110111001
          ! !   ! !!! ! !  !! ! !  ! !!!! != 17
1.0003   00001100000111110010000010010110
------------------------------------------------</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with Python 3.3, a random salt value is included when computing hash codes for <code>str</code>, <code>bytes</code>, and <code>datetime</code> objects,
as documented in <a href="https://bugs.python.org/issue13703">Issue 13703—Hash collision security issue</a>.
The salt value is constant within a Python process but varies between interpreter runs.
With PEP-456, Python 3.4 adopted the SipHash cryptographic function to compute hash codes for <code>str</code> and <code>bytes</code> objects.
The random salt and SipHash are security measures to prevent DoS attacks.
Details are in a note in the documentation for <a href="http://bit.ly/1FESm0m">the <code>__hash__</code> special method</a>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="hash_collisions">Hash collisions</h3>
<div class="paragraph">
<p>As mentioned, on 64-bit CPython a hash code is a 64-bit number, and that’s 2<sup>64</sup> possible values—which is more than 10<sup>19</sup>.
But most Python types can represent many more different values.
For example, a string made of 10 ASCII printable characters picked at random has 100<sup>10</sup> possible values–more than 2<sup>66</sup>.
Therefore, the hash code of an object usually has less information than the actual object value.
This means that objects that are different may have the same hash code.</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>When correctly implemented, hashing guarantees that different hash 
codes always imply different objects, but the reverse is not true: 
different objects don’t always have different hash codes. When different
 objects have the same hash code, that’s a <em>hash collision</em>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>With this basic understanding of hash codes and object equality, we 
are ready to dive into how hash tables work, and how hash collisions are
 handled.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="set_hash_tables_under_sec">Set hash tables under the hood</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hash tables are a wonderful invention. Let’s see how a hash table is used when adding elements to a set.</p>
</div>
<div class="paragraph">
<p>Let’s say we have a set with abbreviated workdays, created like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; workdays = {'Mon', 'Tue', 'Wed', 'Thu', 'Fri'}
&gt;&gt;&gt; workdays
{'Tue', 'Mon', 'Wed', 'Fri', 'Thu'}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The core data structure of a Python <code>set</code> is a hash table with at least 8 rows.
Traditionally, the rows in hash table are called <em>buckets</em><sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>A hash table holding the elements of <code>workdays</code> looks like <a href="#fig_hash_table_0">Figure 3</a>.</p>
</div>
<div id="fig_hash_table_0" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-5.png" alt="Hash table with elements 'Mon' through 'Fri'.">
</div>
<div class="title">Figure 3. Hash table for the set <code>{'Mon', 'Tue', 'Wed', 'Thu', 'Fri'}</code>.
 Each bucket has two fields: the hash code and a pointer to the element 
value. Empty buckets have -1 in the hash code field. The ordering looks 
random.</div>
</div>
<div class="paragraph">
<p>In CPython built for a 64-bit CPU, each bucket in a set has two fields:
a 64-bit hash code, and a 64-bit pointer to the element value—which is a Python object stored elsewhere in memory.
Because buckets have a fixed size, individual buckets are accessed by offset from the start of the hash table.
In other words, the indexes 0 to 7 in <a href="#fig_hash_table_0">Figure 3</a> are not stored, they are just offsets.</p>
</div>
<div class="sect2">
<h3 id="hash_table_algorithm_sec">The hash table algorithm</h3>
<div class="paragraph">
<p>We will focus on the internals of <code>set</code> first, and later transfer the concepts to <code>dict</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This is a simplified view of how Python uses a hash table to implement a <code>set</code>. For all details, see commented source code for CPython’s <code>set</code> and <code>frozenset</code> in <a href="https://github.com/python/cpython/blob/master/Include/setobject.h">Include/setobject.h</a> and <a href="https://github.com/python/cpython/blob/master/Objects/setobject.c">Objects/setobject.c</a>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Let’s see how Python builds a set like <code>{'Mon', 'Tue', 'Wed', 'Thu', 'Fri'}</code>, step by step. The algorithm is illustrated by the flowchart in <a href="#fig_flowchart_hash_add">Figure 4</a>, and described next.</p>
</div>
<div id="fig_flowchart_hash_add" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/flowchart-set-hash-add.png" alt="Hash table algorithm: adding element.">
</div>
<div class="title">Figure 4. Flowchart for algorithm to add element to the hash table of a set.</div>
</div>
<div class="sect3">
<h4 id="_step_0_initialize_hash_table">Step 0: initialize hash table</h4>
<div class="paragraph">
<p>As mentioned earlier, the hash table for a <code>set</code> starts 
with 8 empty buckets. As elements are added, Python makes sure at least ⅓
 of the buckets are empty—doubling the size of the hash table when more 
space is needed. The hash code field of each bucket is initialized with 
-1, which means "no hash code"<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_1_compute_the_hash_code_for_the_element">Step 1: compute the hash code for the element</h4>
<div class="paragraph">
<p>Given the literal <code>{'Mon', 'Tue', 'Wed', 'Thu', 'Fri'}</code>, Python gets the hash code for the first element, <code>'Mon'</code>.
For example, here is a realistic hash code for <code>'Mon'</code>—you’ll probably get a different result because of the random salt Python uses to compute the hash code of strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; hash('Mon')
4199492796428269555</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_2_probe_hash_table_at_index_derived_from_hash_code">Step 2: probe hash table at index derived from hash code</h4>
<div class="paragraph">
<p>Python takes the modulus of the hash code with the table size to find
 a hash table index. Here the table size is 8, and the modulus is 3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; 4199492796428269555 % 8
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Probing consists of computing the index from the hash, then looking at the corresponding bucket in the hash table.
In this case, Python looks at the bucket at offset 3 and finds -1 in the hash code field, marking an empty bucket.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_3_put_the_element_in_the_empty_bucket">Step 3: put the element in the empty bucket</h4>
<div class="paragraph">
<p>Python stores the hash code of the new element, 4199492796428269555, 
in the hash code field at offset 3, and a pointer to the string object <code>'Mon'</code> in the element field. <a href="#fig_hash_table_1">Figure 5</a> shows the current state of the hash table.</p>
</div>
<div id="fig_hash_table_1" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-1.png" alt="Hash table with element 'Mon'.">
</div>
<div class="title">Figure 5. Hash table for the set <code>{'Mon'}</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="_steps_for_remaining_items">Steps for remaining items</h4>
<div class="paragraph">
<p>For the second element, <code>'Tue'</code>, steps 1, 2, 3 above are repeated. The hash code for <code>'Tue'</code> is 2414279730484651250, and the resulting index is 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; hash('Tue')
2414279730484651250
&gt;&gt;&gt; hash('Tue') % 8
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The hash and pointer to element <code>'Tue'</code> are placed in bucket 2, which was also empty. Now we have <a href="#fig_hash_table_2">Figure 6</a></p>
</div>
<div id="fig_hash_table_2" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-2.png" alt="Hash table with elements 'Mon' and 'Tue'.">
</div>
<div class="title">Figure 6. Hash table for the set <code>{'Mon', 'Tue'}</code>. Note that element ordering is not preserved in the hash table.</div>
</div>
</div>
<div class="sect3">
<h4 id="_steps_for_a_collision">Steps for a collision</h4>
<div class="paragraph">
<p>When adding <code>'Wed'</code> to the set, Python computes the hash -5145319347887138165 and index 3.
Python probes bucket 3 and sees that it is already taken. But the hash code stored there, 4199492796428269555 is different.
As discussed in <a href="#hashes_and_equality">Hashes and equality</a>, if two objects have different hashes, then their value is also different.
This is an index collision.
Python then probes the next bucket and finds it empty.
So <code>'Wed'</code> ends up at index 4, as shown in <a href="#fig_hash_table_3">Figure 7</a>.</p>
</div>
<div id="fig_hash_table_3" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-3.png" alt="Hash table with elements 'Mon' and 'Tue'.">
</div>
<div class="title">Figure 7. Hash table for the set <code>{'Mon', 'Tue', 'Wed'}</code>. After the collision, <code>'Wed'</code> is put at index 4.</div>
</div>
<div class="paragraph">
<p>Adding the next element, <code>'Thu'</code>, is boring: there’s no collision, and it lands in its natural bucket, at index 7.</p>
</div>
<div class="paragraph">
<p>Placing <code>'Fri'</code> is more interesting.
Its hash, 7021641685991143771 implies index 3, which is taken by <code>'Mon'</code>. Probing the next bucket—4—Python finds the hash for <code>'Wed'</code> stored there. The hash codes don’t match, so this is another index collision. Python probes the next bucket. It’s empty, so <code>'Fri'</code> ends up at index 5. The end state of the hash table is shown in <a href="#fig_hash_table_4">Figure 8</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Incrementing the index after a collision is called <em>linear probing</em>.
 This can lead to clusters of occupied buckets, which can degrade the 
hash table performance, so CPython counts the number of linear probes 
and after a certain threshold, applies a pseudo random number generator 
to obtain a different index from other bits of the hash code. This 
optimization is particularly important in large sets.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="fig_hash_table_4" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-5.png" alt="Hash table with elements 'Mon' through 'Fri'.">
</div>
<div class="title">Figure 8. Hash table for the set <code>{'Mon', 'Tue', 'Wed', 'Thu', 'Fri'}</code>. It is now 62.5% full—close to the ⅔ threshold.</div>
</div>
<div class="paragraph">
<p>When there is an element in the probed bucket and the hash codes 
match, Python also needs to compare the actual object values. That’s 
because, as explained in <a href="#hash_collisions">Hash collisions</a>,
 it’s possible that two different objects have the same hash 
code—although that’s rare for strings, thanks to the quality of the 
Siphash algorithm<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>. This explains why hashable objects must implement both <code>__hash__</code> and <code>__eq__</code>.</p>
</div>
<div class="paragraph">
<p>If a new element were added to our example hash table, it would be 
more than ⅔ full, therefore increasing the chances of index collisions. 
To prevent that, Python would allocate a new hash table with 16 buckets,
 and reinsert all elements there.</p>
</div>
<div class="paragraph">
<p>All this may seem like a lot of work, but even with millions of items in a <code>set</code>,
 many insertions happen with no collisions, and the average number of 
collisions per insertion is between one and two. Under normal usage, 
even the unluckiest elements can be placed after a handful of collisions
 are resolved.</p>
</div>
<div class="paragraph">
<p>Now, given what we’ve seen so far, follow the flowchart in <a href="#fig_flowchart_hash_add">Figure 4</a> to answer the following puzzle without using the computer.</p>
</div>
<div class="paragraph">
<p>Given the following <code>set</code>, what happens when you add an integer <code>1</code> to it?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; s = {1.0, 2.0, 3.0}
&gt;&gt;&gt; s.add(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>How many elements are in <code>s</code> now? Does <code>1</code> replace the element <code>1.0</code>?
When you have your answer, use the Python console to verify it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_searching_elements_in_a_hash_table">Searching elements in a hash table</h4>
<div class="paragraph">
<p>Consider the <code>workdays</code> set with the hash table shown in <a href="#fig_hash_table_4">Figure 8</a>.
Is <code>'Sat'</code> in it? This is the simplest execution path for the expression <code>'Sat' in workdays</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>hash('Sat')</code> to get a hash code. Let’s say it is 4910012646790914166</p>
</li>
<li>
<p>Derive a hash table index from the hash code, using <code>hash_code % table_size</code>. In this case, the index is 6.</p>
</li>
<li>
<p>Probe offset 6: it’s empty. This means <code>'Sat'</code> is not in the set. Return <code>False</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now consider the simplest path for an element that is present in the set. To evaluate <code>'Thu' in workdays</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>hash('Tue')</code>. Pretend result is 6166047609348267525.</p>
</li>
<li>
<p>Compute index: <code>6166047609348267525 % 8</code> is 5.</p>
</li>
<li>
<p>Probe offset 5:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Compare hash codes. They are equal.</p>
</li>
<li>
<p>Compare the object values. They are equal. Return <code>True</code>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Collisions are handled in the way described when adding an element.
In fact, the flowchart in <a href="#fig_flowchart_hash_add">Figure 4</a> applies to searches as well,
with the exception of the terminal nodes—the rectangles with rounded corners.
If an empty bucket is found, the element is not present, so Python returns <code>False</code>;
otherwise, when both the hash code and the values of the sought element match an element in the hash table, the return is <code>True</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consequences_set_sec">Practical Consequences of How Sets Work</h3>
<div class="paragraph">
<p>The <code>set</code> and <code>frozenset</code> types are both implemented with a hash table, which has these effects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set elements must be hashable objects. They must implement proper <code>__hash__</code> and <code>__eq__</code> methods as described in <a href="#what_is_hashable">[what_is_hashable]</a>.</p>
</li>
<li>
<p>Membership testing is very efficient. A set may have millions of 
elements, but the bucket for an element can be located directly by 
computing the hash code of the element and deriving an index offset, 
with the possible overhead of a small number of probes to find a 
matching element or an empty bucket.</p>
</li>
<li>
<p>Sets have a significant memory overhead. The most compact internal data structure for a container would be an array of pointers<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>. Compared to that, a hash table adds a hash code per entry, and at least ⅓ of empty buckets to minimize collisions.</p>
</li>
<li>
<p>Element ordering depends on insertion order, but not in a useful or 
reliable way. If two elements are involved in a collision, the bucket 
were each is stored depends on which element is added first.</p>
</li>
<li>
<p>Adding elements to a set may change the order of other elements. 
That’s because, as the hash table is filled, Python may need to recreate
 it to keep at least ⅓ of the buckets empty. When this happens, elements
 are reinserted and different collisions may occur.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hash_table_in_dict_sec">Hash table usage in <code>dict</code></h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>May your hashes be unique,<br>
Your keys rarely collide,<br>
And your dictionaries<br>
be forever ordered.<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup></p>
</div>
</blockquote>
<div class="attribution">
— Brandon Rhodes<br>
<cite>in The Dictionary Even Mightier</cite>
</div>
</div>
<div class="paragraph">
<p>Since 2012, the implementation of the <code>dict</code> type had two major optimizations to reduce memory usage.
The first one was proposed as <a href="https://www.python.org/dev/peps/pep-0412/">PEP 412 — Key-Sharing Dictionary</a> and implemented in Python 3.3<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>.
The second is called <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation">"compact <code>dict`"</code></a><code>, and landed in Python 3.6.
As a side effect, the compact `dict</code> space optimization preserves key insertion order.
In the next sections we’ll discuss the compact <code>dict</code> and the new key-sharing scheme—in this order, for easier presentation.</p>
</div>
<div class="sect2">
<h3 id="how_compact_dict_ordering_sec">How compact <code>dict</code> saves space and keeps ordering</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This is a high level explanation of the Python <code>dict</code> implementation.
One difference is that the actual usable fraction of a <code>dict</code> hash table is ⅓, and not ⅔ as in sets.
The actual ⅓ fraction would require 16 buckets to hold the 4 items in my example <code>dict</code>,
and the diagrams in this section would become too tall, so I pretend the usable fraction is ⅔ in these explanations.
One comment in <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c">Objects/dictobject.c</a>
explains that any fraction between ⅓ and ⅔ "seem to work well in practice".</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Consider a <code>dict</code> holding the abbreviated names for the weekdays from <code>'Mon'</code> through <code>'Thu'</code>, and the number of students enrolled in  swimming class on each day:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight language-pycon" role="region" aria-label="code sample"><code class=" language-pycon" data-lang="pycon">&gt;&gt;&gt; swimmers = {'Mon': 14, 'Tue': 12, 'Wed': 14, 'Thu': 11}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before the compact <code>dict</code> optimization, the hash table underlying the <code>swimmers</code> dictionary would look like <a href="#fig_hash_table_dict_old">Figure 9</a>.
As you can see, in a 64-bit Python, each bucket holds three 64-bit fields:
the hash code of the key, a pointer to the key object, and a pointer to the value object.
That’s 24 bytes per bucket.</p>
</div>
<div id="fig_hash_table_dict_old" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-dict-old.png" alt="Hash table for old `dict` with 4 key-value pairs.">
</div>
<div class="title">Figure 9. Old hash table format for a <code>dict</code>
 with 4 key-value pairs. Each bucket is a struct with the hash code of 
the key, a pointer to the key, and a pointer to the value.</div>
</div>
<div class="paragraph">
<p>The first two fields play the same role as they do in the implementation of sets.
To find a key, Python computes the hash code of the key, derives an index from the key,
then probes the hash table to find a bucket with a matching hash code and a matching key object.
The third field provides the main feature of a <code>dict</code>: mapping a key to an arbitrary value.
The key must be a hashable object, and the hash table algorithm ensures it will be unique in the <code>dict</code>.
But the value may be any object—it doesn’t need to be hashable or unique.</p>
</div>
<div class="paragraph">
<p>Raymond Hettinger observed that significant savings could be made if 
the hash code and pointers to key and value were held in an <code>entries</code> array with no empty rows,
and the actual hash table were a sparse array with much smaller buckets holding indexes into the <code>entries</code> array<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>.
In his original <a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html">message to <em>python-dev</em></a>,
Hettinger called the hash table <code>indices</code>. The width of the buckets in <code>indices</code> varies as the <code>dict</code>
 grows, starting at 8-bits per bucket—enough to index up to 128 entries,
 while reserving negative values for special purposes, such as -1 for 
empty and -2 for deleted.</p>
</div>
<div class="paragraph">
<p>As an example, the <code>swimmers</code> dictionary would then be stored as shown in <a href="#fig_hash_table_dict_compact_4">Figure 10</a>.</p>
</div>
<div id="fig_hash_table_dict_compact_4" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-compact-4.png" alt="Arrays for compact `dict` with 4 key-value pairs.">
</div>
<div class="title">Figure 10. Compact storage for a <code>dict</code> with 4 key-value pairs. Hash codes and pointers to keys and values are stored in insertion order in the <code>entries</code> array, and the entry offsets derived from the hash codes are held in the <code>indices</code> sparse array, where an index value of -1 signals an empty bucket.</div>
</div>
<div class="paragraph">
<p>Assuming a 64-bit build of CPython, our 4-item <code>swimmers</code> dictionary would take 192 bytes of memory in the old scheme:
24 bytes per bucket, times 8 rows.
The equivalent compact <code>dict</code> uses 104 bytes in total: 96 bytes in <code>entries</code> (24 * 4),
plus 8 bytes for the buckets in <code>indices</code>—configured as an array of 8 bytes.</p>
</div>
<div class="paragraph">
<p>The next section describes how those two arrays are used.</p>
</div>
<div class="sect3">
<h4 id="_algorithm_for_adding_items_to_compact_dict">Algorithm for adding items to compact <code>dict</code>.</h4>
<div class="sect4">
<h5 id="_step_0_set_up_indices">Step 0: set up <code>indices</code></h5>
<div class="paragraph">
<p>The <code>indices</code> table is initially set up as an array of signed bytes, with 8 buckets, each initialized with -1 to signal "empty bucket".
Up to 5 of these buckets will eventually hold indices to rows in the <code>entries</code> array, leaving ⅓ of them with -1.
The other array, <code>entries</code>, will hold key/value data with the same three fields as in the old scheme—but in insertion order.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_1_compute_hash_code_for_the_key">Step 1: compute hash code for the key</h5>
<div class="paragraph">
<p>To add the key-value pair <code>('Mon', 14)</code> to the <code>swimmers</code> dictionary,
Python first calls <code>hash('Mon')</code> to compute the hash code of that key.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_2_probe_entries_via_indices">Step 2: probe <code>entries</code> via <code>indices</code></h5>
<div class="paragraph">
<p>Python computes <code>hash('Mon') % len(indices)</code>. In our example, this is 3.
Offset 3 in <code>indices</code> holds -1: it’s an empty bucket.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_3_put_key_value_in_entries_updating_indices">Step 3: put key-value in <code>entries</code>, updating <code>indices</code>.</h5>
<div class="paragraph">
<p>The <code>entries</code> array is empty, so the next available offset there is 0.
Python puts 0 at offset 3 in <code>indices</code> and stores
the hash code of the key, a pointer to the key object <code>'Mon'</code>, and a pointer to the <code>int</code> value <code>14</code>
at offset 0 in <code>entries</code>.
<a href="#fig_hash_table_dict_compact_1">Figure 11</a> shows the state of the arrays when the value of <code>swimmers</code> is <code>{'Mon': 14}</code>.</p>
</div>
<div id="fig_hash_table_dict_compact_1" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-compact-1.png" alt="Arrays for compact `dict` with 1 key-value pair.">
</div>
<div class="title">Figure 11. Compact storage for the <code>{'Mon': 14}</code>: <code>indices[3]</code> holds the offset of the first entry: <code>entries[0]</code>.</div>
</div>
</div>
<div class="sect4">
<h5 id="_steps_for_next_item">Steps for next item</h5>
<div class="paragraph">
<p>To add <code>('Tue', 12)</code> to <code>swimmers</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compute hash code of key <code>'Tue'</code>.</p>
</li>
<li>
<p>Compute offset into <code>indices</code>, as <code>hash('Tue') % len(indices)</code>. This is 2. <code>indices[2]</code> has -1. No collision so far.</p>
</li>
<li>
<p>Put the next available <code>entries</code> offset, 1, in <code>indices[2]</code>, then store entry at <code>entries[1]</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now the state is <a href="#fig_hash_table_dict_compact_2">Figure 12</a>. Note that <code>entries</code> holds the key-value pairs in insertion order.</p>
</div>
<div id="fig_hash_table_dict_compact_2" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-compact-2.png" alt="Arrays for compact `dict` with 2 key-value pairs.">
</div>
<div class="title">Figure 12. Compact storage for the <code>{'Mon': 14, 'Tue': 12}</code>.</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_steps_for_a_collision_2">Steps for a collision</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compute hash code of key <code>'Wed'</code>.</p>
</li>
<li>
<p>Now, <code>hash('Wed') % len(indices)</code> is 3. <code>indices[3]</code> has 0, pointing to an existing entry.
Look at the hash code in <code>entries[0]</code>.
That’s the hash code for <code>'Mon'</code>, which happens to be different than the hash code for <code>'Wed'</code>.
This mismatch signals a collision. Probes the next index: <code>indices[4]</code>.
That’s -1, so it can be used.</p>
</li>
<li>
<p>Make <code>indices[4] = 2</code>, because 2 is the next available offset at <code>entries</code>. Then fill <code>entries[2]</code> as usual.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After adding <code>('Wed', 14)</code>, we have <a href="#fig_hash_table_dict_compact_3">Figure 13</a></p>
</div>
<div id="fig_hash_table_dict_compact_3" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-compact-3.png" alt="Arrays for compact `dict` with 3 key-value pairs.">
</div>
<div class="title">Figure 13. Compact storage for the <code>{'Mon': 14, 'Tue': 12, 'Wed': 14}</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="_how_a_compact_dict_grows">How a compact <code>dict</code> grows</h4>
<div class="paragraph">
<p>Recall that the buckets in the <code>indices</code> array are 8 signed bytes initially, enough to hold offsets for up to 5 entries, leaving ⅓ of the buckets empty.
When the 6th item is added to the <code>dict</code>, <code>indices</code> is reallocated to 16 buckets—enough for 10 entry offsets.
The size of <code>indices</code> is doubled as needed, while still holding signed bytes, until the time comes to add the 129th item to the <code>dict</code>.
At this point, the <code>indices</code> array has 256 8-bit buckets. However, a signed byte is not enough to hold offsets after 128 entries,
so the <code>indices</code> array is rebuilt to hold 256 16-bit buckets to hold signed integers—wide enough to represent offsets to 32,768 rows in the <code>entries</code> table.
The next resizing happens at the 171st addition, when <code>indices</code> would become more than ⅔ full.
Then the number of buckets in <code>indices</code> is doubled to 512, but each bucket still 16-bits wide each.
In summary, the <code>indices</code> array grows by doubling the number of buckets,
and also—less often—by doubling the width of each bucket to accommodate a growing number of rows in <code>entries</code>.</p>
</div>
<div class="paragraph">
<p>This concludes our summary of the compact <code>dict</code> implementation.
I omitted many details, but now let’s take a look at the other space-saving optimization for dictionaries: key-sharing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="key_sharing_dict_sec">Key-sharing dictionary</h3>
<div class="paragraph">
<p>Instances of user-defined classes hold their attributes in a <code>__dict__</code>
attribute<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>
which is a regular dictionary.
An instance <code>__dict__</code> maps attribute names to attribute values.
Most of the time, all instances have the same attributes with different values.
When that happens, 2 of the 3 fields in the <code>entries</code> table for every instance have the exact same content:
the hash code of the attribute name, and a pointer to the attribute name.
Only the pointer to the attribute value is different.</p>
</div>
<div class="paragraph">
<p>In <a href="https://www.python.org/dev/peps/pep-0412/">PEP 412 — Key-Sharing Dictionary</a>,
Mark Shannon proposed to split the storage of dictionaries used as instance <code>__dict__</code>,
so that each attribute hash code and pointer is stored only once, linked to the class,
and the attribute values are kept in parallel arrays of pointers attached to each instance.</p>
</div>
<div class="paragraph">
<p>Given a <code>Movie</code> class where all instances have the same attributes named
<code>'title'</code>, <code>'release'</code>, <code>'directors'</code>, and <code>'actors'</code>,
<a href="#fig_hash_table_dict_split">Figure 14</a> shows the arrangement of key-sharing in a split
dictionary—also implemented with the new compact layout.</p>
</div>
<div id="fig_hash_table_dict_split" class="imageblock">
<div class="content">
<img src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/hash-table-split.png" alt="Arrays for split `+__dict__+` with 3 instances.">
</div>
<div class="title">Figure 14. Split storage for the <code>__dict__</code> of a class and three instances.</div>
</div>
<div class="paragraph">
<p>PEP 412 introduced the terms <em>combined-table</em> to discuss the old layout and <em>split-table</em> for the proposed optimization.</p>
</div>
<div class="paragraph">
<p>The combined-table layout is still the default when you create a <code>dict</code> using literal syntax or call <code>dict()</code>.
A split-table dictionary is created to fill the <code>__dict__</code> special attribute of an instance, when it is the first instance of a class.
The keys table (see <a href="#fig_hash_table_dict_split">Figure 14</a>) is then cached in the class object.
This leverages the fact that most Object Oriented Python code assigns all instance attributes in the <code>__init__</code> method.
That first instance (and all instances after it) will hold only its own value array.
If an instance gets a new attribute not found in the shared keys table, then this instance’s <code>__dict__</code> is converted to combined-table form.
However, if this instance is the only one in its class, the <code>__dict__</code> is converted back to split-table,
since it is assumed that further instances will have the same set of attributes and key sharing will be useful.</p>
</div>
<div class="paragraph">
<p>The <code>PyDictObject</code> struct that represents a <code>dict</code> in the CPython source code is the same for both <em>combined-table</em> and <em>split-table</em> dictionaries.
When a <code>dict</code> converts from one layout to the other, the change happens in <code>PyDictObject</code> fields,
with the help of other internal data structures.</p>
</div>
</div>
<div class="sect2">
<h3 id="consequences_dict_sec">Practical Consequences of How dict Works</h3>
<div class="ulist">
<ul>
<li>
<p>Keys must be hashable objects. They must implement proper <code>__hash__</code> and <code>__eq__</code> methods as described in <a href="#what_is_hashable">[what_is_hashable]</a>.</p>
</li>
<li>
<p>Key searches are nearly as fast as element searches in sets.</p>
</li>
<li>
<p>Item ordering is preserved in the <code>entries</code> table—this was implemented in CPython 3.6, and became an official language feature in 3.7.</p>
</li>
<li>
<p>To save memory, avoid creating instance attributes outside of the <code>__init__</code> method. If all instance attributes are created in <code>__init__</code>,
the <code>__dict__</code> of your instances will use the split-table layout, sharing the same indices and key entries array stored with the class.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Since I just mentioned <code>int</code>, here is a CPython implementation detail: the hash code of an <code>int</code> that fits in a machine word is the value of the <code>int</code> itself, except the hash code of -1, which is -2.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. The word "bucket" makes more sense to 
describe hash tables that hold more than one element per row. Python 
stores only one element per row, but we will stick with the colorful 
traditional term.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. The <code>hash()</code> built-in never returns -1 for any Python object. If <code>x.<em>hash</em>()</code> returns -1, <code>hash(x)</code> returns -2.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. On 64-bit CPython, string hash 
collisions are so uncommon that I was unable to produce an example for 
this explanation. If you find one, let me know.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. That’s how tuples are stored.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. PyCon 2017 talk; video available at <a href="https://youtu.be/66P5FMkWoVU?t=56" class="bare">https://youtu.be/66P5FMkWoVU?t=56</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. That was before I started writing the 1<sup>st</sup> edition of <em>Fluent Python</em>, but I missed it.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. It’s ironic that the buckets in the hash table here do not contain hash codes, but only indexes to the <code>entries</code> array where the hash codes are. But, conceptually, the <code>index</code> array is really the hash table in this implementation, even if there are no hashes in its buckets.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. Unless the class has a <a href="https://docs.python.org/3/reference/datamodel.html#slots"><code>__slots__</code></a> attribute.
</div>
</div>

  </main>

          
            <footer role="contentinfo">
  <div>
    <label for="themer">
      dark theme: <input type="checkbox" id="themer" class="vh">
      
      <span aria-hidden="true"></span>
    </label>
  </div>
  
    Made with <a href="https://gohugo.io/">Hugo</a>. Themed by <a href="https://github.com/zwbetz-gh/cupper-hugo-theme">Cupper</a>.
  
</footer>

          
        </div>
      </div>
    </div>
    

<script src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/dom-scripts.js"></script>  

<script src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/prism.js"></script>



<script src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/search.7aef046a0cc8b0c532f1d20087b920459bc868c936bb48a6ae221e.js"></script>

<link rel="stylesheet" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/search.fe0cd54a21628574bff49d721c827d1bb165ab56b0f22dd55ae78.css">



  <script src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/custom_01.js"></script>

  <script src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/custom_02.js"></script>


    
<link rel="stylesheet" href="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
<script defer="defer" src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
<script defer="defer" src="Internals%20of%20sets%20and%20dicts%20Fluent%20Python,%20the%20lizard%20book_files/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    
  

  

</body></html>